// Code generated by protoc-gen-go. DO NOT EDIT.
// source: aft.proto

package aft

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// An enum that tracks the status of each transaction.
type TransactionStatus int32

const (
	// The default status indicates that the transaction is currently running.
	TransactionStatus_RUNNING TransactionStatus = 0
	// This status indicates that the transaction has successfully committed.
	TransactionStatus_COMMITTED TransactionStatus = 1
	// This status indicates that the transaction has successfully aborted.
	TransactionStatus_ABORTED TransactionStatus = 2
)

var TransactionStatus_name = map[int32]string{
	0: "RUNNING",
	1: "COMMITTED",
	2: "ABORTED",
}

var TransactionStatus_value = map[string]int32{
	"RUNNING":   0,
	"COMMITTED": 1,
	"ABORTED":   2,
}

func (x TransactionStatus) String() string {
	return proto.EnumName(TransactionStatus_name, int32(x))
}

func (TransactionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{0}
}

// A token for clients to identify their current transaction.
type TransactionTag struct {
	// The ID of the transaction.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The current status of the transaction (see TransactionStatus).
	Status TransactionStatus `protobuf:"varint,2,opt,name=status,proto3,enum=TransactionStatus" json:"status,omitempty"`
	// The IP address of the replica that received the request.
	Address              string   `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionTag) Reset()         { *m = TransactionTag{} }
func (m *TransactionTag) String() string { return proto.CompactTextString(m) }
func (*TransactionTag) ProtoMessage()    {}
func (*TransactionTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{0}
}

func (m *TransactionTag) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionTag.Unmarshal(m, b)
}
func (m *TransactionTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionTag.Marshal(b, m, deterministic)
}
func (m *TransactionTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionTag.Merge(m, src)
}
func (m *TransactionTag) XXX_Size() int {
	return xxx_messageInfo_TransactionTag.Size(m)
}
func (m *TransactionTag) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionTag.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionTag proto.InternalMessageInfo

func (m *TransactionTag) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TransactionTag) GetStatus() TransactionStatus {
	if m != nil {
		return m.Status
	}
	return TransactionStatus_RUNNING
}

func (m *TransactionTag) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// A message representing an individual transaction.
type TransactionRecord struct {
	// The UUID assigned to this transaction.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The sloppy timestamp given to this transaction by AFT.
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The current status of the transaction (see TransactionStatus).
	Status TransactionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=TransactionStatus" json:"status,omitempty"`
	// The UUID of the write buffer replica assigned to this transaction --
	// primarily used for debugging purposes.
	ReplicaId string `protobuf:"bytes,4,opt,name=replicaId,proto3" json:"replicaId,omitempty"`
	// The set of keys written by this transaction.
	WriteSet []string `protobuf:"bytes,5,rep,name=writeSet,proto3" json:"writeSet,omitempty"`
	// The set of keys that have been read by this transaction. This maps from
	// the user-facing key name to the actual key version read.
	ReadSet              map[string]string `protobuf:"bytes,6,rep,name=readSet,proto3" json:"readSet,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TransactionRecord) Reset()         { *m = TransactionRecord{} }
func (m *TransactionRecord) String() string { return proto.CompactTextString(m) }
func (*TransactionRecord) ProtoMessage()    {}
func (*TransactionRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{1}
}

func (m *TransactionRecord) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionRecord.Unmarshal(m, b)
}
func (m *TransactionRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionRecord.Marshal(b, m, deterministic)
}
func (m *TransactionRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionRecord.Merge(m, src)
}
func (m *TransactionRecord) XXX_Size() int {
	return xxx_messageInfo_TransactionRecord.Size(m)
}
func (m *TransactionRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionRecord.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionRecord proto.InternalMessageInfo

func (m *TransactionRecord) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TransactionRecord) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TransactionRecord) GetStatus() TransactionStatus {
	if m != nil {
		return m.Status
	}
	return TransactionStatus_RUNNING
}

func (m *TransactionRecord) GetReplicaId() string {
	if m != nil {
		return m.ReplicaId
	}
	return ""
}

func (m *TransactionRecord) GetWriteSet() []string {
	if m != nil {
		return m.WriteSet
	}
	return nil
}

func (m *TransactionRecord) GetReadSet() map[string]string {
	if m != nil {
		return m.ReadSet
	}
	return nil
}

// Captures a list of `TransactionRecord`s, used to communicate committed
// transactions between replicas.
type TransactionList struct {
	// The list of `TransactionRecord`s being communicated.
	Records              []*TransactionRecord `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TransactionList) Reset()         { *m = TransactionList{} }
func (m *TransactionList) String() string { return proto.CompactTextString(m) }
func (*TransactionList) ProtoMessage()    {}
func (*TransactionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{2}
}

func (m *TransactionList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionList.Unmarshal(m, b)
}
func (m *TransactionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionList.Marshal(b, m, deterministic)
}
func (m *TransactionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionList.Merge(m, src)
}
func (m *TransactionList) XXX_Size() int {
	return xxx_messageInfo_TransactionList.Size(m)
}
func (m *TransactionList) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionList.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionList proto.InternalMessageInfo

func (m *TransactionList) GetRecords() []*TransactionRecord {
	if m != nil {
		return m.Records
	}
	return nil
}

// A list of transaction UUIDs that are communicated between the GC process and
// the Aft replicas.
type TransactionIdList struct {
	// The list of transaction UUIDs.
	Ids                  []string `protobuf:"bytes,1,rep,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionIdList) Reset()         { *m = TransactionIdList{} }
func (m *TransactionIdList) String() string { return proto.CompactTextString(m) }
func (*TransactionIdList) ProtoMessage()    {}
func (*TransactionIdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{3}
}

func (m *TransactionIdList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionIdList.Unmarshal(m, b)
}
func (m *TransactionIdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionIdList.Marshal(b, m, deterministic)
}
func (m *TransactionIdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionIdList.Merge(m, src)
}
func (m *TransactionIdList) XXX_Size() int {
	return xxx_messageInfo_TransactionIdList.Size(m)
}
func (m *TransactionIdList) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionIdList.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionIdList proto.InternalMessageInfo

func (m *TransactionIdList) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

// A request to read or write a key from an application to the storage engine.
type KeyRequest struct {
	// The transaction ID associated with this request.
	Tid string `protobuf:"bytes,1,opt,name=tid,proto3" json:"tid,omitempty"`
	// A list of requested keys, along with optional bytestrings for PUT requests.
	Pairs                []*KeyRequest_KeyPair `protobuf:"bytes,2,rep,name=pairs,proto3" json:"pairs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *KeyRequest) Reset()         { *m = KeyRequest{} }
func (m *KeyRequest) String() string { return proto.CompactTextString(m) }
func (*KeyRequest) ProtoMessage()    {}
func (*KeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{4}
}

func (m *KeyRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyRequest.Unmarshal(m, b)
}
func (m *KeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyRequest.Marshal(b, m, deterministic)
}
func (m *KeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRequest.Merge(m, src)
}
func (m *KeyRequest) XXX_Size() int {
	return xxx_messageInfo_KeyRequest.Size(m)
}
func (m *KeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRequest proto.InternalMessageInfo

func (m *KeyRequest) GetTid() string {
	if m != nil {
		return m.Tid
	}
	return ""
}

func (m *KeyRequest) GetPairs() []*KeyRequest_KeyPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

// A request to read or write an individual key. If the value is specified,
// the request is treated as a write, and if it is not, the request is
// treated as a read.
type KeyRequest_KeyPair struct {
	// The key being requested.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// An optional value for write requests.
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyRequest_KeyPair) Reset()         { *m = KeyRequest_KeyPair{} }
func (m *KeyRequest_KeyPair) String() string { return proto.CompactTextString(m) }
func (*KeyRequest_KeyPair) ProtoMessage()    {}
func (*KeyRequest_KeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{4, 0}
}

func (m *KeyRequest_KeyPair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyRequest_KeyPair.Unmarshal(m, b)
}
func (m *KeyRequest_KeyPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyRequest_KeyPair.Marshal(b, m, deterministic)
}
func (m *KeyRequest_KeyPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRequest_KeyPair.Merge(m, src)
}
func (m *KeyRequest_KeyPair) XXX_Size() int {
	return xxx_messageInfo_KeyRequest_KeyPair.Size(m)
}
func (m *KeyRequest_KeyPair) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRequest_KeyPair.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRequest_KeyPair proto.InternalMessageInfo

func (m *KeyRequest_KeyPair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyRequest_KeyPair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// A message to represent an update to an individual key, written to the
// storagen engine.
type KeyValuePair struct {
	// The plain key name for this key-value pair. The storage engine key might
	// vary, depending on the versioning scheme, but this is the user-facing key.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The payload for this key-value pair.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// The set of keys written along with this key.
	CowrittenKeys []string `protobuf:"bytes,3,rep,name=cowrittenKeys,proto3" json:"cowrittenKeys,omitempty"`
	// The UUID of the transaction that wrote this update.
	Tid string `protobuf:"bytes,4,opt,name=tid,proto3" json:"tid,omitempty"`
	// The timestamp associated with the transaction that wrote this update.
	Timestamp            int64    `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyValuePair) Reset()         { *m = KeyValuePair{} }
func (m *KeyValuePair) String() string { return proto.CompactTextString(m) }
func (*KeyValuePair) ProtoMessage()    {}
func (*KeyValuePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7743263a823e9ed, []int{5}
}

func (m *KeyValuePair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyValuePair.Unmarshal(m, b)
}
func (m *KeyValuePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyValuePair.Marshal(b, m, deterministic)
}
func (m *KeyValuePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValuePair.Merge(m, src)
}
func (m *KeyValuePair) XXX_Size() int {
	return xxx_messageInfo_KeyValuePair.Size(m)
}
func (m *KeyValuePair) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValuePair.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValuePair proto.InternalMessageInfo

func (m *KeyValuePair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValuePair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *KeyValuePair) GetCowrittenKeys() []string {
	if m != nil {
		return m.CowrittenKeys
	}
	return nil
}

func (m *KeyValuePair) GetTid() string {
	if m != nil {
		return m.Tid
	}
	return ""
}

func (m *KeyValuePair) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func init() {
	proto.RegisterEnum("TransactionStatus", TransactionStatus_name, TransactionStatus_value)
	proto.RegisterType((*TransactionTag)(nil), "TransactionTag")
	proto.RegisterType((*TransactionRecord)(nil), "TransactionRecord")
	proto.RegisterMapType((map[string]string)(nil), "TransactionRecord.ReadSetEntry")
	proto.RegisterType((*TransactionList)(nil), "TransactionList")
	proto.RegisterType((*TransactionIdList)(nil), "TransactionIdList")
	proto.RegisterType((*KeyRequest)(nil), "KeyRequest")
	proto.RegisterType((*KeyRequest_KeyPair)(nil), "KeyRequest.KeyPair")
	proto.RegisterType((*KeyValuePair)(nil), "KeyValuePair")
}

func init() { proto.RegisterFile("aft.proto", fileDescriptor_e7743263a823e9ed) }

var fileDescriptor_e7743263a823e9ed = []byte{
	// 531 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x6d, 0x8b, 0xd3, 0x40,
	0x10, 0x6e, 0x92, 0xbe, 0x98, 0x69, 0xaf, 0x97, 0x1b, 0x45, 0x42, 0x3c, 0xb0, 0x44, 0x85, 0x7a,
	0x48, 0x0e, 0x2b, 0xf8, 0x72, 0x28, 0x52, 0xcf, 0x22, 0xa5, 0x5e, 0x4f, 0xb6, 0x55, 0x3f, 0x6f,
	0x9b, 0x6d, 0x59, 0x6c, 0x9b, 0xba, 0xd9, 0x2a, 0x01, 0x7f, 0x82, 0xbf, 0xc1, 0x9f, 0x2a, 0xb2,
	0x79, 0xb9, 0x26, 0x57, 0xb9, 0xe3, 0xbe, 0xed, 0xcc, 0x3c, 0xb3, 0xcf, 0xf3, 0xec, 0xce, 0x80,
	0x49, 0x67, 0xd2, 0x5b, 0x8b, 0x40, 0x06, 0xce, 0xbd, 0x79, 0x10, 0xcc, 0x17, 0xec, 0x38, 0x8e,
	0x26, 0x9b, 0xd9, 0x31, 0x5b, 0xae, 0x65, 0x94, 0x14, 0xdd, 0x19, 0x34, 0xc7, 0x82, 0xae, 0x42,
	0x3a, 0x95, 0x3c, 0x58, 0x8d, 0xe9, 0x1c, 0x9b, 0xa0, 0x73, 0xdf, 0xd6, 0x5a, 0x5a, 0xdb, 0x24,
	0x3a, 0xf7, 0xf1, 0x08, 0xaa, 0xa1, 0xa4, 0x72, 0x13, 0xda, 0x7a, 0x4b, 0x6b, 0x37, 0x3b, 0xe8,
	0xe5, 0x1a, 0x46, 0x71, 0x85, 0xa4, 0x08, 0xb4, 0xa1, 0x46, 0x7d, 0x5f, 0xb0, 0x30, 0xb4, 0x8d,
	0xf8, 0x82, 0x2c, 0x74, 0xff, 0xe8, 0x70, 0x90, 0xeb, 0x23, 0x6c, 0x1a, 0x08, 0x7f, 0x87, 0xeb,
	0x10, 0x4c, 0xc9, 0x97, 0x2c, 0x94, 0x74, 0xb9, 0x8e, 0xe9, 0x0c, 0xb2, 0x4d, 0xe4, 0x94, 0x18,
	0xd7, 0x2a, 0x39, 0x04, 0x53, 0xb0, 0xf5, 0x82, 0x4f, 0x69, 0xdf, 0xb7, 0xcb, 0x31, 0xc1, 0x36,
	0x81, 0x0e, 0xdc, 0xfa, 0x29, 0xb8, 0x64, 0x23, 0x26, 0xed, 0x4a, 0xcb, 0x68, 0x9b, 0xe4, 0x22,
	0xc6, 0x57, 0x50, 0x13, 0x8c, 0xfa, 0xaa, 0x54, 0x6d, 0x19, 0xed, 0x7a, 0xe7, 0xbe, 0xb7, 0x23,
	0xdc, 0x23, 0x09, 0xa2, 0xb7, 0x92, 0x22, 0x22, 0x19, 0xde, 0x39, 0x81, 0x46, 0xbe, 0x80, 0x16,
	0x18, 0xdf, 0x58, 0x94, 0xfa, 0x53, 0x47, 0xbc, 0x03, 0x95, 0x1f, 0x74, 0xb1, 0x61, 0xb1, 0x39,
	0x93, 0x24, 0xc1, 0x89, 0xfe, 0x52, 0x73, 0xdf, 0xc2, 0x7e, 0x8e, 0xe6, 0x23, 0x0f, 0x25, 0x3e,
	0x51, 0x4a, 0x14, 0x5d, 0x68, 0x6b, 0xb1, 0x12, 0xdc, 0x55, 0x42, 0x32, 0x88, 0xfb, 0xa8, 0xf0,
	0xc0, 0x7d, 0x3f, 0xbe, 0xc2, 0x02, 0x83, 0xa7, 0xed, 0x26, 0x51, 0x47, 0xf7, 0x17, 0xc0, 0x80,
	0x45, 0x84, 0x7d, 0xdf, 0xb0, 0xa4, 0x2e, 0x2f, 0x7e, 0x40, 0x1d, 0xf1, 0x31, 0x54, 0xd6, 0x94,
	0x0b, 0xf5, 0xdb, 0x8a, 0xf2, 0xb6, 0xb7, 0x45, 0xab, 0xe3, 0x27, 0xca, 0x05, 0x49, 0x10, 0xce,
	0x53, 0xa8, 0xa5, 0x99, 0xeb, 0x9c, 0x36, 0x52, 0xa7, 0xee, 0x6f, 0x0d, 0x1a, 0x03, 0x16, 0x7d,
	0x51, 0xc1, 0x4d, 0x1a, 0xf1, 0x21, 0xec, 0x4d, 0x03, 0xf5, 0x47, 0x92, 0xad, 0x06, 0x2c, 0x52,
	0x23, 0xa0, 0x2c, 0x15, 0x93, 0x99, 0x9d, 0xf2, 0xd6, 0x4e, 0x61, 0xa2, 0x2a, 0x97, 0x26, 0xea,
	0xe8, 0x75, 0xe1, 0xcd, 0x92, 0x11, 0xc2, 0x3a, 0xd4, 0xc8, 0xe7, 0xe1, 0xb0, 0x3f, 0xfc, 0x60,
	0x95, 0x70, 0x0f, 0xcc, 0xd3, 0xf3, 0xb3, 0xb3, 0xfe, 0x78, 0xdc, 0x7b, 0x6f, 0x69, 0xaa, 0xd6,
	0x7d, 0x77, 0x4e, 0x54, 0xa0, 0x77, 0xfe, 0x6a, 0x60, 0x74, 0x67, 0x12, 0xdf, 0x80, 0x35, 0x92,
	0x54, 0xc8, 0xdc, 0x55, 0x78, 0xd7, 0x4b, 0xb6, 0xce, 0xcb, 0xb6, 0xce, 0xeb, 0xa9, 0xad, 0x73,
	0xf6, 0xbd, 0xe2, 0xba, 0xb9, 0x25, 0x7c, 0x00, 0x95, 0xaf, 0x6a, 0xf8, 0xb0, 0x9e, 0x7b, 0x6b,
	0x27, 0x1f, 0xb8, 0x25, 0x74, 0xa1, 0xac, 0x46, 0xeb, 0x4a, 0xcc, 0x0b, 0x38, 0x38, 0x0d, 0x96,
	0x4b, 0x5e, 0x10, 0x72, 0x99, 0xf0, 0x7f, 0x0a, 0x9e, 0x83, 0xd5, 0x9d, 0x04, 0xe2, 0xa6, 0x7d,
	0x93, 0x6a, 0x6c, 0xee, 0xd9, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x05, 0xd3, 0xf1, 0xea, 0x6d,
	0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AftClient is the client API for Aft service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AftClient interface {
	// Starts a new transaction in the system and returns a unique transaction
	// ID. The updates made in the context of this transaction will not be
	// persisted until CommitTransaction is called.
	StartTransaction(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TransactionTag, error)
	// Tentatively write a value or batch of values to the storage engine. These
	// writes will not be committed until CommitTransaction is called. If
	// AbortTransaction is called, these writes will be dropped.
	Write(ctx context.Context, in *KeyRequest, opts ...grpc.CallOption) (*KeyRequest, error)
	// Retrieve a value from the storage engine.
	Read(ctx context.Context, in *KeyRequest, opts ...grpc.CallOption) (*KeyRequest, error)
	// Commits buffered writes to the storage engine. The commit is not
	// guaranteed to succeed and may depend on the isolation mechanisms being
	// used in order to determine whether the transactions updates and reads are
	// valid.
	CommitTransaction(ctx context.Context, in *TransactionTag, opts ...grpc.CallOption) (*TransactionTag, error)
	// Aborts all of the updates made by this transaction. The buffered updates
	// will be dropped, and the transaction in the underlying engine will be
	// closed.
	AbortTransaction(ctx context.Context, in *TransactionTag, opts ...grpc.CallOption) (*TransactionTag, error)
}

type aftClient struct {
	cc *grpc.ClientConn
}

func NewAftClient(cc *grpc.ClientConn) AftClient {
	return &aftClient{cc}
}

func (c *aftClient) StartTransaction(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TransactionTag, error) {
	out := new(TransactionTag)
	err := c.cc.Invoke(ctx, "/Aft/StartTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aftClient) Write(ctx context.Context, in *KeyRequest, opts ...grpc.CallOption) (*KeyRequest, error) {
	out := new(KeyRequest)
	err := c.cc.Invoke(ctx, "/Aft/Write", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aftClient) Read(ctx context.Context, in *KeyRequest, opts ...grpc.CallOption) (*KeyRequest, error) {
	out := new(KeyRequest)
	err := c.cc.Invoke(ctx, "/Aft/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aftClient) CommitTransaction(ctx context.Context, in *TransactionTag, opts ...grpc.CallOption) (*TransactionTag, error) {
	out := new(TransactionTag)
	err := c.cc.Invoke(ctx, "/Aft/CommitTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aftClient) AbortTransaction(ctx context.Context, in *TransactionTag, opts ...grpc.CallOption) (*TransactionTag, error) {
	out := new(TransactionTag)
	err := c.cc.Invoke(ctx, "/Aft/AbortTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AftServer is the server API for Aft service.
type AftServer interface {
	// Starts a new transaction in the system and returns a unique transaction
	// ID. The updates made in the context of this transaction will not be
	// persisted until CommitTransaction is called.
	StartTransaction(context.Context, *empty.Empty) (*TransactionTag, error)
	// Tentatively write a value or batch of values to the storage engine. These
	// writes will not be committed until CommitTransaction is called. If
	// AbortTransaction is called, these writes will be dropped.
	Write(context.Context, *KeyRequest) (*KeyRequest, error)
	// Retrieve a value from the storage engine.
	Read(context.Context, *KeyRequest) (*KeyRequest, error)
	// Commits buffered writes to the storage engine. The commit is not
	// guaranteed to succeed and may depend on the isolation mechanisms being
	// used in order to determine whether the transactions updates and reads are
	// valid.
	CommitTransaction(context.Context, *TransactionTag) (*TransactionTag, error)
	// Aborts all of the updates made by this transaction. The buffered updates
	// will be dropped, and the transaction in the underlying engine will be
	// closed.
	AbortTransaction(context.Context, *TransactionTag) (*TransactionTag, error)
}

// UnimplementedAftServer can be embedded to have forward compatible implementations.
type UnimplementedAftServer struct {
}

func (*UnimplementedAftServer) StartTransaction(ctx context.Context, req *empty.Empty) (*TransactionTag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTransaction not implemented")
}
func (*UnimplementedAftServer) Write(ctx context.Context, req *KeyRequest) (*KeyRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Write not implemented")
}
func (*UnimplementedAftServer) Read(ctx context.Context, req *KeyRequest) (*KeyRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedAftServer) CommitTransaction(ctx context.Context, req *TransactionTag) (*TransactionTag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitTransaction not implemented")
}
func (*UnimplementedAftServer) AbortTransaction(ctx context.Context, req *TransactionTag) (*TransactionTag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortTransaction not implemented")
}

func RegisterAftServer(s *grpc.Server, srv AftServer) {
	s.RegisterService(&_Aft_serviceDesc, srv)
}

func _Aft_StartTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AftServer).StartTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aft/StartTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AftServer).StartTransaction(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aft_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AftServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aft/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AftServer).Write(ctx, req.(*KeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aft_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AftServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aft/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AftServer).Read(ctx, req.(*KeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aft_CommitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionTag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AftServer).CommitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aft/CommitTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AftServer).CommitTransaction(ctx, req.(*TransactionTag))
	}
	return interceptor(ctx, in, info, handler)
}

func _Aft_AbortTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionTag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AftServer).AbortTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Aft/AbortTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AftServer).AbortTransaction(ctx, req.(*TransactionTag))
	}
	return interceptor(ctx, in, info, handler)
}

var _Aft_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Aft",
	HandlerType: (*AftServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartTransaction",
			Handler:    _Aft_StartTransaction_Handler,
		},
		{
			MethodName: "Write",
			Handler:    _Aft_Write_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _Aft_Read_Handler,
		},
		{
			MethodName: "CommitTransaction",
			Handler:    _Aft_CommitTransaction_Handler,
		},
		{
			MethodName: "AbortTransaction",
			Handler:    _Aft_AbortTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aft.proto",
}
